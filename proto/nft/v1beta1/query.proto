syntax = "proto3";
package nft.v1beta1;

import "gogoproto/gogo.proto";
import "nft/v1beta1/nft.proto";
import "nft/v1beta1/market_place.proto";
import "google/api/annotations.proto";
import "nft/v1beta1/community.proto";
option go_package = "github.com/AutonomyNetwork/nft/types";

service Query {
  rpc Denom(QueryDenomRequest) returns (QueryDenomResponse) {
    option (google.api.http).get = "/AutonomyNetwork/nft/v1beta1/denoms/{denom_id}";
  }

  rpc Denoms(QueryDenomsRequest) returns (QueryDenomsResponse) {
    option (google.api.http).get = "/AutonomyNetwork/nft/v1beta1/denoms";
  }

  rpc Collection(QueryCollectionRequest) returns(QueryCollectionResponse) {
    option(google.api.http).get = "/AutonomyNetwork/nft/v1beta1/collection/{denom_id}";
  }

  rpc NFT(QueryNFTRequest) returns (QueryNFTResponse) {
    option (google.api.http).get = "/AutonomyNetwork/nft/v1beta1/denoms/{denom_id}/nfts/{id}";
  }

  rpc MarketPlaceNFT(QueryMarketPlaceNFTRequest) returns (QueryMarketPlaceNFTResponse) {
    option (google.api.http).get = "/AutonomyNetwork/nft/v1beta1/market_place/denoms/{denom_id}/nfts/{id}";
  }

  rpc MarketPlace(QueryMarketPlaceRequest) returns (QueryMarketPlaceResponse) {
    option (google.api.http).get = "/AutonomyNetwork/nft/v1beta1/market_place";
  }

  rpc OwnerNFTs(QueryOwnerNFTsRequest) returns (QueryOwnerNFTsResponse) {
    option (google.api.http).get = "/AutonomyNetwork/nft/v1beta1/owner/{owner}/nfts";
  }


  rpc Communities(QueryCommunitiesRequest) returns(QueryCommunitiesResponse) {
    option(google.api.http).get = "/AutonomyNetwork/nft/v1beta1/communities";
  }

  rpc Community(QueryCommunityRequest) returns(QueryCommunityResponse) {
    option(google.api.http).get = "/AutonomyNetwork/nft/v1beta1/communities/{community_id}";
  }

  rpc CommunityMembers(QueryCommunityMembersRequest) returns(QueryCommunityMembersResponse){
    option(google.api.http).get = "/AutonomyNetwork/nft/v1beta1/communities/{community_id}/members";
  }
}

message QueryDenomRequest {
  string denom_id = 1 [(gogoproto.moretags) = "yaml:\"denom_id\""];
}

message QueryDenomResponse {
  Denom denom = 1;
}

message QueryDenomsRequest {}
message QueryDenomsResponse {
  repeated Denom denoms = 1 [(gogoproto.nullable) = false];
}

message QueryNFTRequest {
  string denom_id = 1 [(gogoproto.moretags) = "yaml:\"denom_id\""];
  string id = 2;
}

message QueryNFTResponse {
  NFT nft = 1 [(gogoproto.moretags) = "yaml:\"NFT\"", (gogoproto.customname) = "NFT"];
  Denom denom = 2 ;
}

message QueryMarketPlaceNFTRequest {
  string id = 1;
  string denom_id = 2 [(gogoproto.moretags) = "yaml:\"denom_id\""];
}

message QueryMarketPlaceNFTResponse {
  MarketPlace market_place = 1;
}

message QueryMarketPlaceRequest {}

message QueryMarketPlaceResponse {
  repeated MarketPlace market_place = 1 [(gogoproto.nullable) = false];
}

message QueryOwnerNFTsRequest {
  string owner = 1;
}

message QueryOwnerNFTsResponse {
  string owner = 1;
  repeated OwnerNFTCollection collections = 2 [(gogoproto.nullable) = false];
}

message OwnerNFTCollection {
  Denom denom = 1 [(gogoproto.nullable) = false];
  repeated NFT nfts = 2 [(gogoproto.nullable) = false];
}

message QueryCommunityRequest {
  string community_id = 1 [(gogoproto.moretags) = "yaml:\"community_id\""];
}

message  QueryCommunityResponse {
  Community community = 1;
}


message QueryCommunitiesRequest{
  // TODO: pagination
}
message  QueryCommunitiesResponse {
  repeated Community communities = 1 [(gogoproto.nullable) = false];
}

message QueryCommunityMembersRequest {
  string community_id = 1 ;
}

message  QueryCommunityMembersResponse {
  CommunityMembers members = 1;
}

message QueryCollectionRequest {
  string denom_id = 1;
}

message  QueryCollectionResponse {
  Collection collection = 1;
}